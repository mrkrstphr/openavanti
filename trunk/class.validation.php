<?php
/***************************************************************************************************
 * OpenAvanti
 *
 * OpenAvanti is an open source, object oriented framework for PHP 5+
 *
 * @author			Kristopher Wilson
 * @dependencies 	
 * @copyright		Copyright (c) 2008, Kristopher Wilson
 * @license			http://www.openavanti.com/license
 * @link				http://www.openavanti.com
 * @version			0.6.4-alpha
 *
 */

	/**
	 * Data validation class helper
	 *
	 * @category	Database
	 * @author		Kristopher Wilson
	 * @link			http://www.openavanti.com/docs/validation
	 */
	class Validation
	{ 		
		private static $aErrorList = array();
		
		/**
		 * This class is static and cannot be instantiated
		 */
		private function __construct() {}
		      
      
		/**
		 * Returns whether or not any errors were noted through validation calls
		 *
		 * @returns boolean Returns true if there are any errors stored in the error list, or
		 * 	false otherwise		 
		 */
		public static function HasErrors()
		{		
			return( count( self::$aErrorList ) > 0 );
		
		} // HasErrors()
		
		
      /**
       * Returns the list of errors generated through validation calls. Returns in the format of:
       * 
       * Array(
       *     field1 => array(
       *         0 => "field1 must be between 2 and 32 characters",
       *         1 => "field1 is not between valid email address"       
       *     ),
       *     field2 => array(
       *         0 => "field2 is required"
       *     )		 		 		        
       * )		 		 		        
       * 
       * @returns array An array of error messages generated by validation calls. This array 
       * 	contains a set of arrays for each element name provided to validation calls.		 		        
       */
		public static function GetErrors()
		{
			return( self::$aErrorList );
			
		} // GetErrors()
		

      /**
       * Stores the supplied error in the static error list
       * 
       * @argument string The name of the form field the error occurred on
       * @argument string The error message
       * @returns void		 		 		        
       */
		protected static function SetError( $sKey, $sError )
		{
			self::$aErrorList[ $sKey ][] = $sError;
			
		} // SetError()
		
		
      /*
       * Clears any errors in the error list
       * 
       * @returns void		        
       */
		public static function Clear()
		{
			self::$aErrorList = array();
		
		} // Clear()
		

      /*
       * Validates that the supplied value is not empty. If not, an error message is added to the 
       * list of errors. 
       * 
       * @argument string The name of the field being validated
       * @argument string The data to validate against
       * @argument string Optional, the message to store in the list of validation errors if 
       * 		 validation fails
       * @returns boolean True if the data passes validation, false otherwise			 		 		 		 		 		 		        
       */
		public static function ValidatePresent( $sName, $sValue, $sMessage = "" )
		{
			if( empty( $sMessage ) )
			{
				$sMessage = ucwords( str_replace( "_", " ", $sName ) ) . " is required.";
			}
			
			$sValue = trim( $sValue );
			
			if( empty( $sValue ) )
			{
				self::SetError( $sName, $sMessage );
				return( false );
			}
			
			return( true );
			
		} // ValidatePresent()		

		
      /*
       * Validates that the two supplied values are equal. This method is case insensistive, and
       * also compares the trimmed values. If validation fails, an error message is added to the 
       * list of errors.      
       * 
       * @argument string The name of the field being validated
       * @argument string The value of the field being validated
       * @argument string The value of the field being compared
       * @argument string Optional, the message to store in the list of validation errors if 
       * 		 validation fails
       * @returns boolean True if the data passes validation, false otherwise	 	 		 		 		 		 		 		        
       */
		public static function ValidateEqualTo( $sName, $sValue, $sMatchValue, $sMessage = "" )
		{
			if( empty( $sMessage ) )
			{
				$sMessage = ucwords( str_replace( "_", " ", $sName ) ) . " does not match the " . 
				"required value " . $sMatchValue;
			}
						
			if( strtolower( trim( $sValue ) ) != strtolower( trim( $sMatchValue ) ) )
			{
				self::SetError( $sName, $sMessage );
				return( false );
			}
			
			return( true );
		
		} // ValidateEqualTo()
		

      /*
       * Validates that the supplied data is at least fMin characters in length. This method trims
       * the data before validating. If not, an error message is added to the list of errors. 
       * 
       * @argument string The name of the field being validated
       * @argument string The data to validate against
       * @argument integer The minimum number of characters the supplied data must be in length to 
       * 		 pass validation
       * @argument string Optional, the message to store in the list of validation errors if 
       * 		 validation fails
       * @returns boolean True if the data passes validation, false otherwise			 		 		 		 		 		 		        
       */
		public static function ValidateMinLength( $sName, $sValue, $fMin, $sMessage = "" )
		{
			if( empty( $sMessage ) )
			{
				$sMessage = ucwords( str_replace( "_", " ", $sName ) ) . " must more than " . 
					"{$fMin} characters in length.";
			}
			
			$sValue = trim( $sValue );
			
			if( strlen( $sValue ) < $fMin )
			{
				self::SetError( $sName, $sMessage );
				return( false );
			}
			
			return( true );
		
		} // ValidateMinLength()
		

      /*
       * Validates that the supplied data is not greater than fMax characters in length. This 
       * method trims the data before validating. If not, an error message is added to the list 
       * of errors. 
       * 
       * @argument string The name of the field being validated
       * @argument string The data to validate against
       * @argument integer The maximum number of characters the supplied data must not surpass in 
       * 		 length to pass validation
       * @argument string Optional, the message to store in the list of validation errors if 
       * 		 validation fails
       * @returns boolean True if the data passes validation, false otherwise			 		 		 		 		 		 		        
       */
		public static function ValidateMaxLength( $sName, $sValue, $fMax, $sMessage = "" )
		{
			if( empty( $sMessage ) )
			{
				$sMessage = ucwords( str_replace( "_", " ", $sName ) ) . " must less than " . 
					"{$fMax} characters in length.";
			}
			
			$sValue = trim( $sValue );
			
			if( strlen( $sValue ) > $fMax )
			{
				self::SetError( $sName, $sMessage );
				return( false );
			}
			
			return( true );
		
		} // ValidateMaxLength()


      /*
       * Validates that the supplied value's length is between the supplied minimum and maximum
       * range. This method DOES NOT determine whether the value is in the range, but the number
       * characters in the value is in the supplied range.  This method trims the data before 
       * validating. If not, an error message is added to the list of errors. 
       * 
       * @argument string The name of the field being validated
       * @argument string The data to validate against
       * @argument integer The minimum number of characters the supplied data must be in length to 
       * 		 pass validation
       * @argument integer The maximum number of characters the supplied data must not surpass in 
       * 		 length to pass validation
       * @argument string Optional, the message to store in the list of validation errors if 
       * 		 validation fails
       * @returns boolean True if the data passes validation, false otherwise				 		 		 		 		 		 		        
       */
		public static function ValidateLengthRange( $sName, $sValue, $fMin, $fMax, $sMessage = "" )
		{
			if( empty( $sMessage ) )
			{
				$sMessage = ucwords( str_replace( "_", " ", $sName ) ) . " must be between " . 
					"{$fMin} and {$fMax} characters in length.";
			}
			
			$sValue = trim( $sValue );
			
			if( strlen( $sValue ) < $fMin || strlen( $sValue ) > $fMax )
			{
				self::SetError( $sName, $sMessage );
				return( false );
			}
			
			return( true );
			
		} // ValidateLengthRange()
		

      /*
       * Validates that the supplied data is a valid numeric value. If not, an error message is 
       * added to the list of errors. 
       * 
       * @argument string The name of the field being validated
       * @argument string The data to validate against
       * @argument string Optional, the message to store in the list of validation errors if 
       * 		 validation fails
       * @returns boolean True if the data passes validation, false otherwise			 		 		 		 		 		 		        
       */
		public static function ValidateNumeric( $sName, $sValue, $sMessage = "" )
		{
			if( empty( $sMessage ) )
			{
				$sMessage = ucwords( str_replace( "_", " ", $sName ) ) . " is not a valid numeric " . 
					"value.";
			}
			
			if( !is_numeric( $sValue ) )
			{
				self::SetError( $sName, $sMessage );
				return( false );
			}
			
			return( true );
		
		} // ValidateNumeric()
		

      /*
       * Validates that the supplied data is a valid integer. If not, an error message is added
       * to the list of errors. 
       * 
       * @argument string The name of the field being validated
       * @argument string The data to validate against
       * @argument string Optional, the message to store in the list of validation errors if 
       * 		 validation fails
       * @returns boolean True if the data passes validation, false otherwise			 		 		 		 		 		 		        
       */
		public static function ValidateInteger( $sName, $sValue, $sMessage = "" )
		{
			if( empty( $sMessage ) )
			{
				$sMessage = ucwords( str_replace( "_", " ", $sName ) ) . " must be an integer number.";
			}
			
			if( strval( intval( $sValue ) ) != $sValue )
			{
				self::SetError( $sName, $sMessage );
				return( false );
			}
			
			return( true );
			
		} // ValidateInteger()
						
	
      /*
       * Validates that the supplied data only contains alphabetical characters. If not, an error 
       * message is added to the list of errors. 
       * 
       * @argument string The name of the field being validated
       * @argument string The data to validate against
       * @argument string Optional, the message to store in the list of validation errors if 
       * 		 validation fails
       * @returns boolean True if the data passes validation, false otherwise		 		 		 		 		 		 		        
       */
		public static function ValidateAlpha( $sName, $sValue, $sMessage = "" )
		{
			if( empty( $sMessage ) )
			{
				$sMessage = ucwords( str_replace( "_", " ", $sName ) ) . " can only contain " . 
					"alphabetical characters.";
			}
			
			if( !preg_match( "/^([-a-z])+$/i", $sValue ) )
			{
				self::SetError( $sName, $sMessage );
				return( false );
			}
			
			return( true );
		
		} // ValidateAlpha()
		

      /*
       * Validates that the supplied data only contains alphanumeric characters. If not, an error 
       * message is added to the list of errors. 
       * 
       * @argument string The name of the field being validated
       * @argument string The data to validate against
       * @argument string Optional, the message to store in the list of validation errors if 
       * 		 validation fails
       * @returns boolean True if the data passes validation, false otherwise			 		 		 		 		 		 		        
       */
		public static function ValidateAlphaNumeric( $sName, $sValue, $sMessage = "" )
		{
			if( empty( $sMessage ) )
			{
				$sMessage = ucwords( str_replace( "_", " ", $sName ) ) . " can only contain " . 
					"alphabetical characters.";
			}
			
			if( !preg_match( "/^([-a-z0-9])+$/i", $sValue ) )
			{
				self::SetError( $sName, $sMessage );
				return( false );
			}
			
			return( true );
		
		} // ValidateAlphaNumeric()
		
		
      /*
       * Validates that the supplied data is a valid email address. This method validates both the
       * format of the email address, and that the supplied domain exists. If not, an error message 
       * is added to the list of errors. 
       * 
       * @argument string The name of the field being validated
       * @argument string The data to validate against
       * @argument string Optional, the message to store in the list of validation errors if 
       * 		 validation fails
       * @returns boolean True if the data passes validation, false otherwise			 		 		 		 		 		 		        
       */
		public static function ValidateEmail( $sName, $sValue, $sMessage = "" )
		{
			if( empty( $sMessage ) )
			{
				$sMessage = ucwords( str_replace( "_", " ", $sName ) ) . " can only contain " . 
					"alphabetical characters.";
			}
			
			$sValue = trim( $sValue );
			
			// Format
			
			$sPreg = "/^([a-zA-Z0-9])+([a-zA-Z0-9\._-])*@([a-zA-Z0-9_-])+([a-zA-Z0-9\._-]+)+$/";
									
			if( !preg_match( $sPreg, $sValue ) )
			{
				self::SetError( $sName, $sMessage );
				return( false );
			}
			
			
			// MX Records
			
			$bValidMXRecord = false;

			list( $sLocal, $sDomain ) = split( "@", $sValue );
			
			$aMXHosts = array();
			
			if( !getmxrr( $sDomain, $aMXHosts ) )
			{
				if( @fsockopen( $sDomain, 25, $iErrorNo, $sError, 30 ) )
				{
					$bValidMXRecord = true;
				}
			}
			else
			{
				foreach( $aMXHosts as $sHost )
				{
					if( @fsockopen( $sHost, 25, $iErrorNo, $sError,30 ) )
					{
						$bValidMXRecord = true;
					}
				}
			}
			
			if( !$bValidMXRecord )
			{
				self::SetError( $sName, $sMessage );
				return( false );
			}
					
			return( true );
		
		} // ValidateEmail()
		
		
      /*
       * Validates that the supplied data is a valid US postal code format, either a 5 or 9 
       * character format. This method does not validate that the postal code is a valid zip code
       * registered with USPS. If not, an error message is added to the list of errors. 
       * 
       * @argument string The name of the field being validated
       * @argument string The data to validate against
       * @argument string Optional, the message to store in the list of validation errors if 
       * 		 validation fails
       * @returns boolean True if the data passes validation, false otherwise			 		 		 		 		 		 		        
       */
		public static function ValidateZipCode( $sName, $sValue, $sMessage = "" )
		{
			if( empty( $sMessage ) )
			{
				$sMessage = ucwords( str_replace( "_", " ", $sName ) ) . " does not appear to be " . 
					"a valid US zip code.";
			}
			
			$sValue = trim( $sValue );
			$sValue = str_replace( "-", "", $sValue );
			
			if( strlen( $sValue ) != 5 && strlen( $sValue ) != 9 )
			{
				self::SetError( $sName, $sMessage );
				return( false );
			}
			
			if( strval( intval( $sValue ) ) != $sValue )
			{
				self::SetError( $sName, $sMessage );
				return( false );
			}
			
			return( true );
		
		} // ValidateZipCode()


      /*
       * Validates that a file was uploaded based on the name of the file field. If validation 
       * fails, an error message is added to the list of errors.      
       * 
       * @argument string The name of the file field to validate
       * @argument string Optional, the message to store in the list of validation errors if 
       * 		 validation fails	        
       * @returns boolean True if the data passes validation, false otherwise			 		 		 		 		 		 		        
       */
		public static function ValidateFilePresent( $sName, $sMessage = "" )
		{
			if( empty( $sMessage ) )
			{
				$sMessage = "No file was uploaded for " . ucwords( str_replace( "_", " ", $sName ) ) . 
				".";
			}
			
			if( !isset( $_FILES[ $sName ] ) || empty( $_FILES[ $sName ][ "tmp_name" ] ) )
			{
				self::SetError( $sName, $sMessage );
				return( false );
			}
			
			return( true );
		
		} // ValidateFilePresent()


      /*
       * Validates that an uploaded file is one of the supplied mime types. If FileInfo extension 
       * is not installed, this method relies on the mime type sent by the browser, and this type
       * cannot be trusted, or may not even be present. OpenAvanti recommends installing FileInfo. 
       * If validation fails, an error message is added to the list of errors.      
       * 
       * @argument string The name of the file field to validate
       * @argument array An array of file extensions that are valid for the uploaded file       
       * @argument string Optional, the message to store in the list of validation errors if 
       * 		 validation fails	        
       * @returns boolean True if the data passes validation, false otherwise			 		 		 		 		 		 		        
       */
		public static function ValidateFileMimeType( $sName, $aMimeTypes, $sMessage = "" )
		{
			if( empty( $sMessage ) )
			{
				$sMessage = ucwords( str_replace( "_", " ", $sName ) ) . " must be one of the " . 
					"following mime types: " . implode( ", ", $aMimeTypes ) . ".";
			}
			
			if( isset( $_FILES[ $sName ] ) && !empty( $_FILES[ $sName ][ "tmp_name" ] ) )
			{
				$sMimeType = FileFunctions::GetMimeType( $_FILES[ $sName ][ "tmp_name" ] );
				
				if( is_null( $sMimeType ) )
				{
					$sMimeType = $_FILES[ $sName ][ "tmp_name" ][ "type" ];
				}
				
				if( !in_array( $sMimeType, $aMimeTypes ) )
				{
					self::SetError( $sName, $sMessage );
					return( false );
				}
			}
			
			return( true );
		
		} // ValidateFileMimeType()


      /*
       * Validates that the size of an uploaded file does not exceed a certain file size. If 
       * validation fails, an error message is added to the list of errors. 
       * 
       * @argument string The name of the file field to validate
       * @argument integer The maximum size the file is allowed to be     
       * @argument string Optional, the message to store in the list of validation errors if 
       * 		 validation fails	        
       * @returns boolean True if the data passes validation, false otherwise			 		 		 		 		 		 		        
       */
		public static function ValidateFileMaxSize( $sName, $iSizeInBytes, $sMessage = "" )
		{
			if( empty( $sMessage ) )
			{
				$sMessage = ucwords( str_replace( "_", " ", $sName ) ) . " must be less than " . 
					FileFunctions::HumanReadableSize( $iSizeInBytes ) . " in size.";
			}
			
			if( isset( $_FILES[ $sName ] ) && !empty( $_FILES[ $sName ][ "size" ] ) )
			{				
				if( $_FILES[ $sName ][ "size" ] > $iSizeInBytes )
				{
					self::SetError( $sName, $sMessage );
					return( false );
				}
			}
			
			return( true );
		
		} // ValidateFileMaxSize()


	}; // Validation()

?>
